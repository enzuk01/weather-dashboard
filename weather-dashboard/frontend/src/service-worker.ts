/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }: { request: Request; url: URL }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== 'navigate') {
            return false;
        }

        // If this is a URL that starts with /_, skip.
        if (url.pathname.startsWith('/_')) {
            return false;
        }

        // If this looks like a URL for a resource, because it contains
        // a file extension, skip.
        if (fileExtensionRegexp.test(url.pathname)) {
            return false;
        }

        // Return true to signal that we want to use the handler.
        return true;
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache weather API responses
registerRoute(
    ({ url }) => url.pathname.startsWith('/weather/'),
    new NetworkFirst({
        cacheName: 'weather-api-cache',
        plugins: [
            new ExpirationPlugin({
                // Cache for a maximum of 1 hour
                maxAgeSeconds: 60 * 60,
                // Don't keep more than 50 entries in the cache
                maxEntries: 50,
            }),
        ],
    })
);

// Cache images with a Cache First strategy
registerRoute(
    ({ request }) => request.destination === 'image',
    new CacheFirst({
        cacheName: 'images-cache',
        plugins: [
            new ExpirationPlugin({
                // Cache for a maximum of 30 days
                maxAgeSeconds: 30 * 24 * 60 * 60,
                // Don't keep more than 50 entries in the cache
                maxEntries: 50,
            }),
        ],
    })
);

// Cache CSS, JS with a Stale While Revalidate strategy
registerRoute(
    ({ request }) =>
        request.destination === 'style' ||
        request.destination === 'script' ||
        request.destination === 'font',
    new StaleWhileRevalidate({
        cacheName: 'static-resources',
    })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});

// Any other custom service worker logic can go here.
// Instead of a custom fetch handler with TypeScript errors, use Workbox's offline fallback
registerRoute(
    // Match all navigation requests
    ({ request }) => request.mode === 'navigate',
    // Use a Network First strategy
    new NetworkFirst({
        // Fall back to the cache after 3 seconds
        networkTimeoutSeconds: 3,
        cacheName: 'pages-cache',
        plugins: [
            // If offline and not in cache, show the offline page
            {
                handlerDidError: async () => {
                    return await caches.match('/offline.html') ||
                        new Response('You are offline', {
                            status: 503,
                            headers: { 'Content-Type': 'text/plain' }
                        });
                }
            }
        ]
    })
);

// Add handlers for online/offline events
self.addEventListener('online', () => {
    self.clients.matchAll().then((clients) => {
        clients.forEach((client) => {
            client.postMessage({ type: 'ONLINE' });
        });
    });
});

// Notify clients when they go offline
self.addEventListener('offline', () => {
    self.clients.matchAll().then((clients) => {
        clients.forEach((client) => {
            client.postMessage({ type: 'OFFLINE' });
        });
    });
});

clientsClaim();